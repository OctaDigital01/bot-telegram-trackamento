#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Bot Telegram - Funil de Vendas com Tracking Completo
Conecta com API Gateway
Vers√£o com Fluxo de Funil Otimizado, Remarketing e Aprova√ß√£o em Background
Token Fix: 22/08/2025
"""
import os
import logging
import asyncio
import json
import base64
import httpx
from html import escape
from dotenv import load_dotenv
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto, InputMediaVideo
from telegram.ext import Application, CommandHandler, ContextTypes, CallbackQueryHandler, ChatJoinRequestHandler
from telegram.constants import ParseMode
from telegram.error import BadRequest, Conflict

# Carregar vari√°veis do arquivo .env
load_dotenv()

# ==============================================================================
# 1. CONFIGURA√á√ÉO GERAL E INICIALIZA√á√ÉO
# ==============================================================================

# Vari√°vel global para controlar inst√¢ncia √∫nica
_BOT_INSTANCE = None

# ======== CONFIGURA√á√ÉO DE LOGGING =============
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)
# ==============================================

# ======== VARI√ÅVEIS DE AMBIENTE (CR√çTICAS) =============
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')
API_GATEWAY_URL = os.getenv('API_GATEWAY_URL')
ADMIN_ID = int(os.getenv('ADMIN_ID', '0')) if os.getenv('ADMIN_ID') else None
GROUP_ID = int(os.getenv('GRUPO_GRATIS_ID', '0')) if os.getenv('GRUPO_GRATIS_ID') else None
GROUP_INVITE_LINK = os.getenv('GRUPO_GRATIS_INVITE_LINK')
GROUP_VIP_ID = int(os.getenv('GRUPO_VIP_ID', '0')) if os.getenv('GRUPO_VIP_ID') else None
GROUP_VIP_INVITE_LINK = os.getenv('GRUPO_VIP_INVITE_LINK')
SITE_ANA_CARDOSO = os.getenv('SITE_ANA_CARDOSO')
# =======================================================

# ======== FILE IDs DAS M√çDIAS ATUALIZADOS =============
MEDIA_APRESENTACAO = os.getenv('MEDIA_APRESENTACAO')
MEDIA_VIDEO_QUENTE = os.getenv('MEDIA_VIDEO_QUENTE')
MEDIA_PREVIA_SITE = os.getenv('MEDIA_PREVIA_SITE')
MEDIA_PROVOCATIVA = os.getenv('MEDIA_PROVOCATIVA')
# ====================================================

# ======== CONFIGURA√á√ÉO DOS PLANOS VIP =============
VIP_PLANS = {
    "plano_1": {"id": "plano_1mes", "nome": "ACESSO VIP COMPLETO", "valor": 24.90, "botao_texto": "üí¶ R$ 24,90 - ME VER SEM CENSURA"},
    "plano_2": {"id": "plano_3meses", "nome": "VIP + PACK ESPECIAL", "valor": 49.90, "botao_texto": "üî• R$ 49,90 - TUDO + PACK EXCLUSIVO"},
    "plano_3": {"id": "plano_1ano", "nome": "ACESSO TOTAL + EU S√ì PRA VOC√ä", "valor": 67.00, "botao_texto": "üíé R$ 67,00 - SER MEU NAMORADO VIP"}
}
# ==================================================

# ======== CONFIGURA√á√ÉO DE REMARKETING E DESCONTO =============
REMARKETING_PLANS = {
    "plano_desc_etapa5": {"id": "plano_desc_etapa5", "nome": "VIP com Desconto (Remarketing)", "valor": 19.90, "botao_texto": "ü§ë QUERO O VIP COM DESCONTO DE R$19,90"},
    "plano_desc_20_off": {"id": "plano_desc_20_off", "nome": "VIP com 20% OFF", "valor": 19.90, "botao_texto": "ü§ë QUERO MEU DESCONTO DE 20% AGORA"}
}
# ==================================================

# ======== JUN√á√ÉO DE TODOS OS PLANOS PARA ACESSO R√ÅPIDO =============
TODOS_OS_PLANOS = {**VIP_PLANS, **REMARKETING_PLANS}
# =================================================================

# ======== CONFIGURA√á√ÉO DE DELAYS (NOVOS TEMPOS) =============
CONFIGURACAO_BOT = {
    "DELAYS": {
        "ETAPA_1_FALLBACK": 20,         # (20s) Se n√£o clicar para entrar no grupo
        "ETAPA_2_FALLBACK": 20,         # (20s) Se n√£o clicar para ver pr√©via
        "ETAPA_3_FALLBACK": 40,         # (40s) Se n√£o clicar no "QUERO O VIP", envia remarketing
        "ETAPA_4_FALLBACK": 60,         # (1min) Se n√£o escolher plano, envia desconto
        "APROVACAO_GRUPO_BG": 40,       # (40s) Tempo para aprovar a entrada no grupo em background
        "PIX_TIMEOUT": 3600,            # (60min) Tempo para expirar o PIX
    }
}
# ========================================================

# ======== CLIENTE HTTP ASS√çNCRONO =============
http_client = httpx.AsyncClient(
    timeout=httpx.Timeout(10.0, read=30.0),
    limits=httpx.Limits(max_keepalive_connections=5, max_connections=10)
)
# ==============================================

# ==============================================================================
# 2. FUN√á√ïES AUXILIARES E DE L√ìGICA REUTILIZ√ÅVEL
# ==============================================================================

#======== DELETA MENSAGEM ANTERIOR USANDO user_data (UNIFICADO) =============
async def delete_previous_message(context: ContextTypes.DEFAULT_TYPE, message_key: str):
    """
    Deleta uma mensagem anterior cujo ID est√° salvo em context.user_data.
    """
    if message_key in context.user_data:
        chat_id = context.user_data.get('chat_id')
        message_id = context.user_data[message_key]
        if chat_id and message_id:
            try:
                await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
                logger.info(f"üóëÔ∏è Mensagem '{message_key}' (ID: {message_id}) deletada com sucesso.")
            except BadRequest as e:
                if "message to delete not found" in str(e).lower():
                    logger.warning(f"‚ö†Ô∏è Mensagem '{message_key}' (ID: {message_id}) j√° havia sido deletada.")
                else:
                    logger.warning(f"‚ö†Ô∏è Erro ao deletar mensagem '{message_key}' (ID: {message_id}): {e}")
            except Exception as e:
                logger.error(f"‚ùå Erro cr√≠tico ao deletar mensagem '{message_key}' (ID: {message_id}): {e}")
            finally:
                # Remove a chave independentemente do resultado para evitar tentativas futuras
                del context.user_data[message_key]
#================= FECHAMENTO ======================

async def verificar_pix_existente(user_id: int, plano_id: str):
    #======== VERIFICA SE J√Å EXISTE PIX V√ÅLIDO PARA O PLANO =============
    try:
        response = await http_client.get(f"{API_GATEWAY_URL}/api/pix/verificar/{user_id}/{plano_id}")
        if response.status_code == 200:
            result = response.json()
            if result.get('success') and result.get('pix_valido'):
                return result.get('pix_data')
    except Exception as e:
        logger.error(f"‚ùå Erro verificando PIX existente: {e}")
    return None
    #================= FECHAMENTO ======================

async def invalidar_pix_usuario(user_id: int):
    #======== INVALIDA TODOS OS PIX PENDENTES DO USU√ÅRIO =============
    try:
        response = await http_client.post(f"{API_GATEWAY_URL}/api/pix/invalidar/{user_id}")
        if response.status_code == 200:
            result = response.json()
            return result.get('success', False)
    except Exception as e:
        logger.error(f"‚ùå Erro invalidando PIX do usu√°rio: {e}")
    return False
    #================= FECHAMENTO ======================

async def check_if_user_is_member(context: ContextTypes.DEFAULT_TYPE, user_id: int) -> bool:
    #======== VERIFICA SE USU√ÅRIO J√Å √â MEMBRO DO GRUPO =============
    try:
        member = await context.bot.get_chat_member(chat_id=GROUP_ID, user_id=user_id)
        return member.status in ['member', 'administrator', 'creator']
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è Erro verificando se usu√°rio {user_id} √© membro do grupo: {e}")
        return False
    #================= FECHAMENTO ======================

async def decode_tracking_data(encoded_param: str):
    #======== DECODIFICA DADOS DE TRACKING =============
    logger.info(f"üîç Decodificando tracking: {encoded_param}")
    if not encoded_param or encoded_param.strip() == '':
        return {'utm_source': 'direct_bot', 'click_id': 'direct_access'}
    
    try:
        # M√©todo 1: Base64 JSON
        try:
            decoded_bytes = base64.b64decode(encoded_param.encode('utf-8'))
            tracking_data = json.loads(decoded_bytes.decode('utf-8'))
            logger.info(f"‚úÖ Tracking Base64 decodificado: {tracking_data}")
            return tracking_data
        except (json.JSONDecodeError, Exception):
            pass # Tenta o pr√≥ximo m√©todo

        # M√©todo 2: Formato :: separado
        if '::' in encoded_param:
            parts = encoded_param.split('::')
            tracking_data = {
                'utm_source': parts[0] if len(parts) > 0 and parts[0] else None,
                'click_id': parts[1] if len(parts) > 1 and parts[1] else None
            }
            tracking_data = {k: v for k, v in tracking_data.items() if v}
            logger.info(f"‚úÖ Tracking :: formato decodificado: {tracking_data}")
            return tracking_data
        
        # Fallback: usa como click_id direto
        logger.info(f"‚ö†Ô∏è Usando fallback - click_id direto: {encoded_param}")
        return {'click_id': encoded_param}
        
    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico decodifica√ß√£o: {e}")
        return {'click_id': encoded_param, 'utm_source': 'decode_error'}
    #================= FECHAMENTO ======================

async def remove_job_if_exists(name: str, context: ContextTypes.DEFAULT_TYPE) -> bool:
    #======== REMOVE UM JOB AGENDADO =============
    if not context.job_queue: return False
    current_jobs = context.job_queue.get_jobs_by_name(name)
    if not current_jobs: return False
    for job in current_jobs:
        job.schedule_removal()
    return True
    #================= FECHAMENTO ======================

async def job_timeout_pix(context: ContextTypes.DEFAULT_TYPE):
    #======== JOB EXECUTADO AP√ìS TIMEOUT SEM PAGAMENTO =============
    job = context.job
    chat_id = job.chat_id
    user_id = job.user_id
    
    logger.info(f"‚è∞ TIMEOUT PIX: Executando para usu√°rio {user_id}")
    
    try:
        if await invalidar_pix_usuario(user_id):
            logger.info(f"üóëÔ∏è PIX expirado invalidado para usu√°rio {user_id}")
        
        texto_desconto_timeout = (
            "üò≥ <b>Opa, meu amor... vi que voc√™ n√£o finalizou o pagamento!</b>\n\n"
            "üíî Sei que √†s vezes a gente fica na d√∫vida, n√©?\n\n"
            "üéÅ <b>√öLTIMA CHANCE:</b> Vou liberar um <b>DESCONTO ESPECIAL</b> s√≥ pra voc√™!\n\n"
            "‚ö° <b>20% OFF + B√¥nus Exclusivos!</b>\n\n"
            "üî• <b>√â AGORA OU NUNCA, amor...</b> üëá"
        )
        
        plano_desc = REMARKETING_PLANS["plano_desc_20_off"]
        keyboard = [[InlineKeyboardButton(plano_desc["botao_texto"], callback_data=f"plano:{plano_desc['id']}")]]
        
        await context.bot.send_message(
            chat_id=chat_id, 
            text=texto_desconto_timeout, 
            reply_markup=InlineKeyboardMarkup(keyboard), 
            parse_mode='HTML'
        )
        logger.info(f"‚úÖ Mensagem de desconto especial enviada para {user_id}")
        
    except Exception as e:
        logger.error(f"‚ùå Erro no timeout PIX para usu√°rio {user_id}: {e}")
    #================= FECHAMENTO ======================

# ==============================================================================
# 3. L√ìGICA DO FUNIL DE VENDAS (POR ETAPA)
# ==============================================================================

# ------------------------- ETAPA 1: BEM-VINDO E CONVITE GRUPO -------------------------
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== GERENCIA O COMANDO /START =============
    user = update.effective_user
    chat_id = update.effective_chat.id
    
    context.user_data.clear()
    context.user_data['chat_id'] = chat_id
    
    if await invalidar_pix_usuario(user.id):
        logger.info(f"üóëÔ∏è PIX anteriores do usu√°rio {user.id} invalidados no /start")
    
    if 'user_chat_map' not in context.bot_data:
        context.bot_data['user_chat_map'] = {}
    context.bot_data['user_chat_map'][user.id] = chat_id
    
    logger.info(f"üë§ ETAPA 1: Usu√°rio {user.first_name} ({user.id}) iniciou o bot.")
    
    tracking_param = ' '.join(context.args) if context.args else ''
    tracking_data = await decode_tracking_data(tracking_param)
    logger.info(f"üéØ Tracking processado: {tracking_data}")
    
    try:
        user_data_payload = {
            'telegram_id': user.id,
            'username': user.username or user.first_name,
            'first_name': user.first_name,
            'last_name': user.last_name or '',
            'tracking_data': tracking_data
        }
        response = await http_client.post(f"{API_GATEWAY_URL}/api/users", json=user_data_payload)
        if response.status_code == 200 and response.json().get('success'):
            logger.info(f"‚úÖ Usu√°rio {user.id} salvo/atualizado na API")
        else:
            logger.error(f"‚ùå Erro salvando usu√°rio {user.id}: {response.status_code} - {response.text}")
    except Exception as e:
        logger.error(f"‚ùå Erro cr√≠tico ao salvar usu√°rio {user.id}: {e}")

    if await check_if_user_is_member(context, user.id):
        text = "Que bom te ver de volta, meu bem! üòç\n\nJ√° que voc√™ j√° t√° no grupinho, que tal ver uns conte√∫dinhos especiais que preparei pra voc√™? üî•"
        keyboard = [[InlineKeyboardButton("VER CONTE√öDINHO ü•µ", callback_data='trigger_etapa3')]]
        await context.bot.send_photo(chat_id=chat_id, photo=MEDIA_APRESENTACAO, caption=text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)
        context.job_queue.run_once(job_etapa3_galeria, CONFIGURACAO_BOT["DELAYS"]["ETAPA_2_FALLBACK"], chat_id=chat_id, name=f"job_etapa3_{chat_id}", data={'chat_id': chat_id})
    else:
        text = "Meu bem, entra no meu *GRUPINHO GR√ÅTIS* pra ver daquele jeito q vc gosta ü•µ‚¨áÔ∏è"
        keyboard = [[InlineKeyboardButton("ENTRAR NO GRUPO ü•µ", url=GROUP_INVITE_LINK)]]
        await context.bot.send_photo(chat_id=chat_id, photo=MEDIA_APRESENTACAO, caption=text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.MARKDOWN)
        context.job_queue.run_once(job_etapa2_prompt_previa, CONFIGURACAO_BOT["DELAYS"]["ETAPA_1_FALLBACK"], chat_id=chat_id, name=f"job_etapa2_{chat_id}", data={'chat_id': chat_id})
    #================= FECHAMENTO ======================

# ------------------------- ETAPA 1.5: PEDIDO DE ENTRADA NO GRUPO -------------------------
async def handle_join_request(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== GERENCIA PEDIDOS DE ENTRADA NO GRUPO =============
    if update.chat_join_request.chat.id != GROUP_ID: return
    
    user_id = update.chat_join_request.from_user.id
    logger.info(f"ü§ù Pedido de entrada no grupo recebido de {user_id}.")
    
    chat_id = context.bot_data.get('user_chat_map', {}).get(user_id)
    if not chat_id:
        logger.warning(f"‚ö†Ô∏è Chat_id n√£o encontrado para {user_id}. Aprova√ß√£o manual necess√°ria.")
        return

    await remove_job_if_exists(f"job_etapa2_{chat_id}", context)
    
    text = "Jaja te aceito meu amor, mas antes que tal ver uns conteudinhos meus?? üëÄ"
    keyboard = [[InlineKeyboardButton("VER CONTEUDINHOS üî•", callback_data='trigger_etapa3')]]
    msg = await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=InlineKeyboardMarkup(keyboard))
    context.user_data['etapa2_msg'] = msg.message_id
    
    context.job_queue.run_once(job_etapa3_galeria, CONFIGURACAO_BOT["DELAYS"]["ETAPA_2_FALLBACK"], chat_id=chat_id, name=f"job_etapa3_{chat_id}", data={'chat_id': chat_id})
    context.job_queue.run_once(approve_user_callback, CONFIGURACAO_BOT["DELAYS"]["APROVACAO_GRUPO_BG"], user_id=user_id, name=f"approve_{user_id}", data={'user_id': user_id, 'chat_id': GROUP_ID})
    #================= FECHAMENTO ======================

async def approve_user_callback(context: ContextTypes.DEFAULT_TYPE):
    #======== APROVA O USU√ÅRIO NO GRUPO (JOB) =============
    job_data = context.job.data
    user_id = job_data['user_id']
    group_chat_id = job_data['chat_id']
    try:
        await context.bot.approve_chat_join_request(chat_id=group_chat_id, user_id=user_id)
        logger.info(f"‚úÖ Aprovada entrada de {user_id} no grupo {group_chat_id}.")
    except Exception as e:
        logger.error(f"‚ùå Falha ao aprovar {user_id} no grupo {group_chat_id}: {e}")
    #================= FECHAMENTO ======================

# ------------------------- ETAPA 2: PROMPT DE PR√âVIA -------------------------
async def job_etapa2_prompt_previa(context: ContextTypes.DEFAULT_TYPE):
    #======== ENVIA PERGUNTA SOBRE PR√âVIAS (FALLBACK) =============
    chat_id = context.job.data['chat_id']
    logger.info(f"‚è∞ ETAPA 2: Enviando prompt de pr√©via para {chat_id}.")
    
    text = "Quer ver um pedacinho do que te espera... üî• (√â DE GRA√áA!!!) ‚¨áÔ∏è"
    keyboard = [[InlineKeyboardButton("QUERO VER UMA PR√âVIA üî•ü•µ", callback_data='trigger_etapa3')]]
    msg = await context.bot.send_message(chat_id=chat_id, text=text, reply_markup=InlineKeyboardMarkup(keyboard))
    context.user_data['etapa2_msg'] = msg.message_id
    
    context.job_queue.run_once(job_etapa3_galeria, CONFIGURACAO_BOT["DELAYS"]["ETAPA_2_FALLBACK"], chat_id=chat_id, name=f"job_etapa3_{chat_id}", data={'chat_id': chat_id})
    #================= FECHAMENTO ======================

# ------------------------- ETAPA 3: GALERIA DE M√çDIAS E OFERTA VIP -------------------------
async def callback_trigger_etapa3(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== GATILHO MANUAL DA ETAPA 3 (CLIQUE NO BOT√ÉO) =============
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    
    logger.info(f"üë§ ETAPA 3: Usu√°rio {chat_id} clicou para ver pr√©vias.")
    
    await remove_job_if_exists(f"job_etapa3_{chat_id}", context)
    await query.delete_message()
    
    await job_etapa3_galeria(context, chat_id_manual=chat_id)
    #================= FECHAMENTO ======================

async def job_etapa3_galeria(context: ContextTypes.DEFAULT_TYPE, chat_id_manual=None):
    #======== ENVIA GALERIA DE M√çDIAS E OFERTA VIP =============
    chat_id = chat_id_manual or context.job.data['chat_id']
    logger.info(f"‚è∞ ETAPA 3: Enviando galeria de m√≠dias para {chat_id}.")
    
    await delete_previous_message(context, 'etapa2_msg')
    
    media_group = [
        InputMediaVideo(media=MEDIA_VIDEO_QUENTE),
        InputMediaPhoto(media=MEDIA_APRESENTACAO),
        InputMediaPhoto(media=MEDIA_PREVIA_SITE),
        InputMediaPhoto(media=MEDIA_PROVOCATIVA)
    ]
    await context.bot.send_media_group(chat_id=chat_id, media=media_group)
    
    text_vip = "Gostou do que viu, meu bem ü§≠?\n\nTenho muito mais no VIP pra voc√™ (TOTALMENTE SEM CENSURA).\n\nVem gozar porra quentinha pra mimü•µüí¶‚¨áÔ∏è"
    keyboard = [[InlineKeyboardButton("QUERO O VIPüî•", callback_data='trigger_etapa4')]]
    msg = await context.bot.send_message(chat_id=chat_id, text=text_vip, reply_markup=InlineKeyboardMarkup(keyboard))
    context.user_data['etapa3_msg'] = msg.message_id
    
    context.job_queue.run_once(job_etapa3_remarketing, CONFIGURACAO_BOT["DELAYS"]["ETAPA_3_FALLBACK"], chat_id=chat_id, name=f"job_etapa3_remarketing_{chat_id}", data={'chat_id': chat_id})
    #================= FECHAMENTO ======================

async def job_etapa3_remarketing(context: ContextTypes.DEFAULT_TYPE):
    #======== ENVIA MENSAGEM DE REMARKETING (FALLBACK DA ETAPA 3) =============
    chat_id = context.job.data['chat_id']
    logger.info(f"‚è∞ ETAPA 3 (FALLBACK): Enviando remarketing breve para {chat_id}.")
    
    await delete_previous_message(context, 'etapa3_msg')
    
    texto_remarketing = "Ei, amor... n√£o some n√£o. Tenho uma surpresinha pra voc√™. Clica aqui pra gente continuar üî•"
    keyboard = [[InlineKeyboardButton("CONTINUAR CONVERSANDO üî•", callback_data='trigger_etapa4')]]
    await context.bot.send_message(chat_id=chat_id, text=texto_remarketing, reply_markup=InlineKeyboardMarkup(keyboard))
    #================= FECHAMENTO ======================

# ------------------------- ETAPA 4: PLANOS VIP E DESCONTO -------------------------
async def callback_trigger_etapa4(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== GATILHO MANUAL DA ETAPA 4 (CLIQUE NO BOT√ÉO) =============
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    
    logger.info(f"üë§ ETAPA 4: Usu√°rio {chat_id} clicou para conhecer o VIP.")
    
    await remove_job_if_exists(f"job_etapa3_remarketing_{chat_id}", context)
    await query.delete_message()
    
    await job_etapa4_planos_vip(context, chat_id_manual=chat_id)
    #================= FECHAMENTO ======================
    
async def job_etapa4_planos_vip(context: ContextTypes.DEFAULT_TYPE, chat_id_manual=None):
    #======== MOSTRA OS PLANOS VIP =============
    chat_id = chat_id_manual or context.job.data['chat_id']
    logger.info(f"‚è∞ ETAPA 4: Enviando planos VIP para {chat_id}.")
    
    texto_planos = (
        "üíã <b>Agora vem a parte gostosa, meu amor...</b>\n\n"
        "üî• No meu VIP voc√™ vai ter:\n"
        "‚Ä¢ V√≠deos completos SEM CENSURA\n"
        "‚Ä¢ Fotos √≠ntimas que s√≥ meus namorados veem\n"
        "‚Ä¢ Chamadas privadas s√≥ eu e voc√™\n"
        "‚Ä¢ Meu WhatsApp pessoal (plano premium)\n\n"
        "üòà <b>Escolhe como voc√™ quer me ter:</b>"
    )
    keyboard = [[InlineKeyboardButton(p["botao_texto"], callback_data=f"plano:{p['id']}")] for p in VIP_PLANS.values()]
    msg = await context.bot.send_message(chat_id=chat_id, text=texto_planos, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
    context.user_data['etapa4_msg'] = msg.message_id
    
    context.job_queue.run_once(job_etapa4_desconto, CONFIGURACAO_BOT["DELAYS"]["ETAPA_4_FALLBACK"], chat_id=chat_id, name=f"job_etapa4_desconto_{chat_id}", data={'chat_id': chat_id})
    #================= FECHAMENTO ======================

async def job_etapa4_desconto(context: ContextTypes.DEFAULT_TYPE):
    #======== OFERECE DESCONTO (FALLBACK DA ETAPA 4) =============
    chat_id = context.job.data['chat_id']
    logger.info(f"‚è∞ ETAPA 4 (FALLBACK): Oferecendo desconto para {chat_id}.")
    
    await delete_previous_message(context, 'etapa4_msg')
    
    texto_desconto = "Ei, meu bem... vi que voc√™ ficou na d√∫vida. ü§î\n\nPra te ajudar a decidir, liberei um <b>desconto especial S√ì PRA VOC√ä</b>. Mas corre que √© por tempo limitado! üëá"
    plano_desc = REMARKETING_PLANS["plano_desc_20_off"]
    keyboard = [[InlineKeyboardButton(plano_desc["botao_texto"], callback_data=f"plano:{plano_desc['id']}")]]
    await context.bot.send_message(chat_id=chat_id, text=texto_desconto, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
    #================= FECHAMENTO ======================

# ------------------------- ETAPA 5: PROCESSAMENTO DO PAGAMENTO -------------------------
async def callback_processar_plano(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== PROCESSA PAGAMENTO DO PLANO SELECIONADO =============
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    user_id = query.from_user.id
    
    await remove_job_if_exists(f"job_etapa4_desconto_{chat_id}", context)
    await query.delete_message()
    
    plano_id = query.data.split(":")[1]
    plano_selecionado = next((p for p in TODOS_OS_PLANOS.values() if p["id"] == plano_id), None)

    if not plano_selecionado: 
        logger.warning(f"‚ö†Ô∏è Plano '{plano_id}' n√£o encontrado para {user_id}.")
        await context.bot.send_message(chat_id, "‚ùå Ops! Ocorreu um erro. Por favor, tente novamente.")
        return

    # L√≥gica para reutilizar ou gerar novo PIX
    pix_existente = await verificar_pix_existente(user_id, plano_id)
    if pix_existente:
        logger.info(f"‚ôªÔ∏è Reutilizando PIX para {user_id} - Plano: {plano_selecionado['nome']}")
        await enviar_mensagem_pix(context, chat_id, user_id, plano_selecionado, pix_existente, is_reused=True)
    else:
        logger.info(f"üí≥ Gerando PIX NOVO para {user_id} - Plano: {plano_selecionado['nome']}")
        msg_loading = await context.bot.send_message(chat_id=chat_id, text="üíé Gerando seu PIX... aguarde! ‚è≥")
        context.user_data['loading_msg'] = msg_loading.message_id
        try:
            pix_data = {
                'user_id': user_id, 'valor': plano_selecionado['valor'], 'plano_id': plano_id,
                'customer': {'name': query.from_user.full_name, 'email': f'user{user_id}@telegram.bot'}
            }
            response = await http_client.post(f"{API_GATEWAY_URL}/api/pix/gerar", json=pix_data)
            response.raise_for_status()
            result = response.json()
            if not result.get('success') or not result.get('pix_copia_cola'):
                raise Exception(f"API PIX retornou erro ou dados incompletos: {result.get('error', 'Erro desconhecido')}")
            
            await delete_previous_message(context, 'loading_msg')
            await enviar_mensagem_pix(context, chat_id, user_id, plano_selecionado, result)
        except Exception as e:
            logger.error(f"‚ùå Erro CR√çTICO ao processar pagamento para {user_id}: {e}")
            await delete_previous_message(context, 'loading_msg')
            await context.bot.send_message(chat_id, "‚ùå Um erro inesperado ocorreu. Por favor, tente novamente mais tarde.")
    #================= FECHAMENTO ======================

async def enviar_mensagem_pix(context: ContextTypes.DEFAULT_TYPE, chat_id: int, user_id: int, plano: dict, pix_data: dict, is_reused: bool = False):
    #======== ENVIA A MENSAGEM COM O QR CODE E DADOS DO PIX =============
    pix_copia_cola = pix_data['pix_copia_cola']
    qr_code_url = pix_data.get('qr_code') or f"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data={pix_copia_cola}"
    
    caption = (
        f"üíé <b>Seu PIX est√° aqui, meu amor!</b>\n\n"
        f"üì∏ <b>Pague utilizando o QR Code</b>\n"
        f"üí∏ <b>Pague por Pix copia e cola:</b>\n"
        f"<blockquote><code>{escape(pix_copia_cola)}</code></blockquote>"
        f"<i>(Clique para copiar)</i>\n\n"
        f"üéØ <b>Plano:</b> {escape(plano['nome'])}\n"
        f"üí∞ <b>Valor: R$ {plano['valor']:.2f}</b>"
    )
    keyboard = [
        [InlineKeyboardButton("‚úÖ J√Å PAGUEI", callback_data=f"ja_paguei:{plano['id']}")],
        [InlineKeyboardButton("üîÑ ESCOLHER OUTRO PLANO", callback_data="escolher_outro_plano")]
    ]
    
    try:
        await context.bot.send_photo(chat_id=chat_id, photo=qr_code_url, caption=caption, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
    except Exception as e:
        logger.error(f"‚ùå Falha ao enviar foto do QR Code para {user_id}: {e}. Enviando fallback.")
        await context.bot.send_message(chat_id=chat_id, text=caption, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')

    # Agenda o job de timeout
    await remove_job_if_exists(f"timeout_pix_{user_id}", context)
    timeout_seconds = CONFIGURACAO_BOT["DELAYS"]["PIX_TIMEOUT"]
    if is_reused:
        try:
            tempo_restante_str = pix_data.get('tempo_restante', '60')
            timeout_seconds = int(tempo_restante_str.split()[0]) * 60 if tempo_restante_str != '??' else timeout_seconds
        except (ValueError, IndexError):
            logger.warning("N√£o foi poss√≠vel parsear o tempo restante do PIX reutilizado.")

    context.job_queue.run_once(job_timeout_pix, timeout_seconds, chat_id=chat_id, user_id=user_id, name=f"timeout_pix_{user_id}")
    logger.info(f"‚è∞ Job de timeout PIX agendado para {user_id} em {timeout_seconds/60:.0f} minutos.")
    #================= FECHAMENTO ======================

async def callback_ja_paguei(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== HANDLER PARA BOT√ÉO "J√Å PAGUEI" =============
    query = update.callback_query
    await query.answer("√ìtimo! Estamos processando seu pagamento.", show_alert=False)
    user_id = query.from_user.id
    
    await remove_job_if_exists(f"timeout_pix_{user_id}", context)
    logger.info(f"‚è∞ Job de timeout PIX cancelado para {user_id} ap√≥s confirma√ß√£o de pagamento.")
    
    texto_confirmacao = (
        "üéâ <b>Perfeito, meu amor!</b>\n\n"
        "Seu pagamento j√° est√° sendo processado! ‚ö°\n\n"
        "üì± <b>Assim que for aprovado, voc√™ receber√° o acesso ao grupo VIP aqui mesmo.</b>\n\n"
        "‚è∞ <i>Geralmente demora apenas alguns segundos...</i>"
    )
    await query.message.edit_caption(caption=texto_confirmacao, parse_mode='HTML')
    #================= FECHAMENTO ======================

async def callback_escolher_outro_plano(update: Update, context: ContextTypes.DEFAULT_TYPE):
    #======== HANDLER PARA BOT√ÉO "ESCOLHER OUTRO PLANO" =============
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    user_id = query.from_user.id
    
    logger.info(f"üîÑ Usu√°rio {user_id} quer escolher outro plano")
    
    await query.delete_message()
    
    if await invalidar_pix_usuario(user_id):
        logger.info(f"üóëÔ∏è PIX anterior invalidado para {user_id}.")
    
    await remove_job_if_exists(f"timeout_pix_{user_id}", context)
    
    texto_upgrade = (
        "üíé <b>√ìtima escolha, amor!</b>\n\n"
        "üî• <b>Quem pega o plano mais completo sempre agradece depois!</b>\n"
        "‚Ä¢ Muito mais conte√∫do exclusivo\n"
        "‚Ä¢ Contato direto e prioridade\n\n"
        "üí∞ <b>E o custo-benef√≠cio √© MUITO melhor!</b>\n\n"
        "<b>Qual voc√™ quer escolher agora?</b> üëá"
    )
    keyboard = [[InlineKeyboardButton(p["botao_texto"], callback_data=f"plano:{p['id']}")] for p in VIP_PLANS.values()]
    await context.bot.send_message(chat_id=chat_id, text=texto_upgrade, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='HTML')
    #================= FECHAMENTO ======================

# ==============================================================================
# 4. FUN√á√ÉO PRINCIPAL E EXECU√á√ÉO DO BOT
# ==============================================================================
async def main():
    #======== INICIALIZA E EXECUTA O BOT DE FORMA ASS√çNCRONA =============
    global _BOT_INSTANCE
    
    if _BOT_INSTANCE:
        logger.warning("‚ö†Ô∏è Bot j√° est√° rodando, abortando nova inst√¢ncia.")
        return
    
    required_vars = ['TELEGRAM_BOT_TOKEN', 'API_GATEWAY_URL', 'GRUPO_GRATIS_ID', 'GRUPO_GRATIS_INVITE_LINK']
    if any(not os.getenv(var) for var in required_vars):
        logger.critical("‚ùå ERRO CR√çTICO: Vari√°veis de ambiente obrigat√≥rias n√£o configuradas.")
        return
        
    logger.info("ü§ñ === BOT COM FUNIL OTIMIZADO INICIANDO ===")
    
    application = Application.builder().token(BOT_TOKEN).build()
    _BOT_INSTANCE = application
    
    # Registra os handlers
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(ChatJoinRequestHandler(handle_join_request))
    application.add_handler(CallbackQueryHandler(callback_trigger_etapa3, pattern='^trigger_etapa3$'))
    application.add_handler(CallbackQueryHandler(callback_trigger_etapa4, pattern='^trigger_etapa4$'))
    application.add_handler(CallbackQueryHandler(callback_processar_plano, pattern='^plano:'))
    application.add_handler(CallbackQueryHandler(callback_ja_paguei, pattern='^ja_paguei:'))
    application.add_handler(CallbackQueryHandler(callback_escolher_outro_plano, pattern='^escolher_outro_plano$'))
    
    try:
        logger.info("üöÄ Bot pronto para iniciar o polling...")
        await application.initialize()
        await application.start()
        await application.updater.start_polling(
            allowed_updates=['message', 'callback_query', 'chat_join_request'],
            drop_pending_updates=True
        )
        logger.info("‚úÖ Bot online e recebendo atualiza√ß√µes.")
        # Mant√©m o script rodando indefinidamente
        await asyncio.Event().wait()

    except Conflict as e:
        logger.error(f"‚ùå CONFLITO: Outra inst√¢ncia do bot pode estar rodando. {e}")
    except Exception as e:
        logger.critical(f"‚ùå Erro fatal na execu√ß√£o do bot: {e}", exc_info=True)
    finally:
        logger.info("üõë Encerrando o bot...")
        if application.updater and application.updater.is_running():
            await application.updater.stop()
        if application:
            await application.stop()
            await application.shutdown()
        if http_client:
            await http_client.aclose()
            logger.info("üîí Cliente HTTP encerrado.")
        _BOT_INSTANCE = None
        logger.info("‚úÖ Bot encerrado com sucesso.")
#================= FECHAMENTO ======================

if __name__ == '__main__':
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("üõë Execu√ß√£o interrompida pelo usu√°rio.")
